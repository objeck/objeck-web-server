use System.Concurrency;
use Collection.Generic;
use System.IO.Net;

#~
Mini web server
~#
class SSLServer {
	@server : static : TCPSecureSocketServer;
	
	function : Main(args : String[]) ~ Nil {
		if(args->Size() = 4) {
			cert := args[0];
			cert_key := args[1];
			cert_key_passwd := args[2];
			port := args[3]->ToInt();

			platform := Runtime->GetPlatform();
			host := TCPSocket->HostName();
			
			MyHandler->Init();
			Runtime->SetSignal(Runtime->Signal->SIGINT, Shutdown(Int) ~ Nil);
			@server := TCPSecureSocketServer->New(cert, cert_key, cert_key_passwd, port);

			if(@server->Listen()) {
			 	"Running on {$host} ({$platform}) port {$port}..."->PrintLine();
				while(true) {
					MyHandler->New(true)->Execute(@server->Accept());
				};
			}
			else {
				# TODO: log errors
				err_msg := @server->GetLastError();
				"Error: '{$err_msg}'"->ErrorLine();
			};
		};
  	}

	function : Shutdown(id : Int) ~ Nil {
		if(@server <> Nil) {
			@server->Close();
		};
		"Shutting down..."->PrintLine();
		Runtime->Exit(0);
	}
}

#~
Request handler
~#
class RequestHandler from Thread {
	@client : TCPSecureSocket;
	@debug : Bool;

	New(debug : Bool) {
		Parent();		
		@debug := debug;
	}

	

	method : public : Run(param : Base) ~ Nil {
		@client := param->As(TCPSecureSocket);

		if(@client <> Nil & @client->IsOpen()) {
			# get request
			request := @client->ReadLine();
			if(@debug) {
				request_address := @client->GetAddress();
				"Request: '{$request}' from '{$request_address}'"->PrintLine();
			};

			# parse request
			request_verb : String; request_url : String;
			if(request->Size() > 0) {
				request_parts := request->Split(" ");
				if(request_parts->Size() = 3) {
					request_verb := request_parts[0];
					request_url := request_parts[1];
				};
			};

			# verify request
			if(request_verb <> Nil & request_url <> Nil & <>request_url->IsEmpty()) {
				# get request headers
				request_headers := GetHeaders();

				# GET request
				if(request_verb->Equals("GET")) {

					# retrieve content
					if(request_url = Nil | request_url->Equals("/") | request_url->Has("..")) {
						request_url := "/index.html";
					};

					# write response
					response_headers := Map->New()<String, String>;
					content := ProcessGet(request_url, request_headers, response_headers);
					if(content <> Nil) {
						response_header := "";
						key_values := response_headers->GetKeyValues()<Pair<String, String>>;
						each(i : key_values) {
							key_value := key_values->Get(i);
							key := key_value->GetFirst();
							value := key_value->GetSecond();
							response_header += "{$key}: {$value}\r\n";
						};

						content_size := content->Size();
						response_header += "Content-Length: {$content_size}\r\nAccept-Ranges: bytes\r\nConnection: close\r\n";
						@client->WriteString("HTTP/1.1 200 OK\r\n{$response_header}\r\n");
						@client->WriteBuffer(content);
					}
					else {
						@client->WriteString("HTTP/1.1 302 Found\r\nLocation: /index.html\r\nConnection: close\r\n\r\n");
					};
				}
				# POST request
				else if(request_verb->Equals("POST")) {
					content_length := request_headers->Find("Content-Length");
					if(content_length <> Nil) {
						buffer := Byte->New[content_length->ToInt()];
						@client->ReadBuffer(0, buffer->Size(), buffer);
						if(ProcessPost(buffer)) {
							@client->WriteString("HTTP/1.1 200 OK\r\nConnection: close\r\n\r\n");
						}
						else {

						};
					};
				};
			};
			
			@client->Close();
		};
	}
	
	method : public : GetHeaders() ~ Map<String, String> {
		headers := Map->New()<String, String>;
		
		header := @client->ReadLine();
		while(header <> Nil & header->Size() > 0) {
			# "header: {$header}"->PrintLine();			
			header_parts := header->Split(": ");
			if(header_parts->Size() = 2) {
				headers->Insert(header_parts[0], header_parts[1]);
			};

			header := @client->ReadLine();
		};

		return headers;
	}

	method : virtual : ProcessGet(request_url : String, request_headers : Map<String, String>, response_headers : Map<String, String>) ~ Byte[];

	method : virtual : ProcessPost(buffer : Byte[]) ~ Bool;
}

#~
My handler
~#
class MyHandler from RequestHandler {
	@content_cache : static : Cache<String, ByteArrayHolder>;
	@content_type_cache : static : Hash<String, String>;
	@content_mutex : static : ThreadMutex;
	
	function : Init() ~ Nil {
		# MIME type mapping
		@content_type_cache := Hash->New()<String, String>;
		@content_type_cache->Insert(".html", "text/html");
		@content_type_cache->Insert(".htm", "text/html");
		@content_type_cache->Insert(".css", "text/css");
		@content_type_cache->Insert(".png", "image/png");
		@content_type_cache->Insert(".jpg", "image/jpeg");
		@content_type_cache->Insert(".ico", "image/x-icon");
		@content_type_cache->Insert(".js", "application/javascript");

		@content_cache := Cache->New(Cache->Type->MRU, 16)<String, ByteArrayHolder>;
		@content_mutex := ThreadMutex->New("__content_cache__");
	}

	New(debug : Bool) {
		Parent(debug);
	}

	method : ProcessGet(request_url : String, request_headers : Map<String, String>, response_headers : Map<String, String>) ~ Byte[] {
		content : Byte[];

		request_type_index := request_url->FindLast('.');
		if(request_type_index > 0) {
			# check the request type
			request_type := request_url->SubString(request_type_index, request_url->Size() - request_type_index);
			if(request_type <> Nil) {
				content_type := @content_type_cache->Find(request_type);
				if(content_type <> Nil) {
					path_name := "./html";
					path_name += request_url;

					# lock cache for while we search or insert content
					critical(@content_mutex) {
						# found in cache
						found := @content_cache->Find(path_name);
						if(found <> Nil) {
							content := found->Get();
						}
						# not found, add to cache
						else {
							content := System.IO.File.FileReader->ReadBinaryFile(path_name);
							if(content <> Nil) {
								@content_cache->Insert(path_name, ByteArrayHolder->New(content));
							};
						};
					};

					if(content <> Nil) {
						response_headers->Insert("Content-type", "{$content_type}");
					};
				};
			};
		};

		return content;
	}

	method : ProcessPost(buffer : Byte[]) ~ Bool {
		content := String->New(buffer);
		content->PrintLine();
		return true;
	}
}